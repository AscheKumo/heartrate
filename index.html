<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ashlyn's Heartrate</title>
  <style>
    html,body { height:100%; margin:0; background:#000; color:#fff; font-family:system-ui,Arial; overflow:hidden; }
    .wrap { height:100%; display:flex; align-items:center; justify-content:center; }
    .card { text-align:center; user-select:none; }
    .title { font-size:18px; font-weight:600; margin-bottom:10px; }
    .bpm { font-size:72px; font-weight:700; margin:0; }
    .graph { display:block; margin:10px auto 0; width:240px; height:40px; }
    .muted { opacity:0.65; }
    .status { font-size:10px; color:rgba(255,255,255,0.35); margin-top:6px; height:12px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" aria-live="polite">
      <div class="title">Ashlyn's Heartrate</div>
      <div id="bpm" class="bpm muted">— BPM</div>
      <canvas id="spark" class="graph" width="240" height="40" aria-hidden="true"></canvas>
      <div id="status" class="status" aria-hidden="true">waiting…</div>
    </div>
  </div>

  <script>
    // Set this to your Cloudflare Worker URL (no Authorization header required here)
    // e.g. 'https://my-pulsoid-proxy.example.workers.dev/heart'
    const API_URL = 'https://your-worker.example.workers.dev/heart';
    const POLL_INTERVAL_MS = 500;
    const MAX_POINTS = 40;

    const bpmEl = document.getElementById('bpm');
    const statusEl = document.getElementById('status');
    const canvas = document.getElementById('spark');
    const ctx = canvas.getContext('2d');

    function scaleCanvas() {
      const dpr = window.devicePixelRatio || 1;
      const styleW = canvas.clientWidth;
      const styleH = canvas.clientHeight;
      canvas.width = Math.max(1, Math.floor(styleW * dpr));
      canvas.height = Math.max(1, Math.floor(styleH * dpr));
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    scaleCanvas();
    window.addEventListener('resize', () => { scaleCanvas(); drawSparkline(); });

    const history = [];

    function setBpmDisplay(value) {
      if (typeof value === 'number' && Number.isFinite(value)) {
        bpmEl.textContent = value + ' BPM';
        bpmEl.classList.remove('muted');
      } else {
        bpmEl.textContent = '— BPM';
        bpmEl.classList.add('muted');
      }
    }

    function pushValue(v) {
      history.push(v == null ? null : Number(v));
      while (history.length > MAX_POINTS) history.shift();
    }

    function drawSparkline() {
      const w = canvas.width / (window.devicePixelRatio || 1);
      const h = canvas.height / (window.devicePixelRatio || 1);
      ctx.clearRect(0,0,w,h);
      const vals = history.filter(v => v != null && Number.isFinite(v));
      if (vals.length === 0) {
        ctx.strokeStyle = 'rgba(255,255,255,0.07)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2,3]);
        ctx.beginPath();
        ctx.moveTo(0, h/2);
        ctx.lineTo(w, h/2);
        ctx.stroke();
        ctx.setLineDash([]);
        return;
      }
      let min = Math.min(...vals), max = Math.max(...vals);
      if (min === max) { min = min - 3; max = max + 3; }
      const range = max - min || 1;
      ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(0,0,w,h);
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.6; ctx.beginPath();
      const step = w / (MAX_POINTS - 1);
      let x = 0;
      for (let i=0;i<history.length;i++){
        const v = history[i];
        if (v == null || !Number.isFinite(v)) { x += step; continue; }
        const y = h - ((v - min) / range) * h;
        if (i === 0 || history[i-1] == null) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        x += step;
      }
      ctx.stroke();
      const lastIndex = history.length - 1;
      const lastVal = history[lastIndex];
      if (lastVal != null && Number.isFinite(lastVal)) {
        const lastX = Math.min(w, lastIndex * step);
        const lastY = h - ((lastVal - min) / range) * h;
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(lastX, lastY, 2.2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    async function fetchHeartRate() {
      try {
        const res = await fetch(API_URL, { method: 'GET', cache: 'no-store' });
        statusEl.textContent = `HTTP ${res.status}`;
        if (res.status === 412) {
          pushValue(null); setBpmDisplay(null); drawSparkline(); return;
        }
        if (!res.ok) {
          pushValue(null); setBpmDisplay(null); drawSparkline(); return;
        }
        const txt = await res.text();
        const parsed = Number(txt.trim());
        if (Number.isFinite(parsed)) {
          pushValue(parsed); setBpmDisplay(parsed);
        } else {
          pushValue(null); setBpmDisplay(null);
        }
        drawSparkline();
      } catch (err) {
        console.error('Fetch error', err);
        statusEl.textContent = err && err.message ? err.message : String(err);
        pushValue(null); setBpmDisplay(null); drawSparkline();
      }
    }

    fetchHeartRate();
    setInterval(fetchHeartRate, POLL_INTERVAL_MS);
  </script>
</body>
</html>
